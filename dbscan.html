<!DOCTYPE html>
<html>
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.8/d3.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js"></script>
<style>
body {
   margin: 1rem;
   font-family: Tahoma;
   font-size: 0.85rem;
}
div {
   margin: 0.5rem;
}
</style>
</head>
<body>
<h3>DBSCAN</h3>

<div style="float:left"><svg id="canvas"><svg></div>
<div style="float:left;width:60%">
   <div>
      Select minimum cluster size: <span id="sizeLabel">4</span><br>
      <input id="sizeSlider" type="range" min="2" max="25" value="4" oninput="updateInput()"/>
   </div>
   <div>
      Select minimum distance: <span id="distLabel">20</span><br>
      <input id="distSlider" type="range" min="5" max="50" value="20" oninput="updateInput()"/>
      <div>
         <svg id="summary"></svg>
      </div>
   </div>
</div>
</body>
<script>

var w = 400;
var h = 400;
var vis;

var dataPoints = [];
var clusters = [];

var numPoints = 400;
var minimumSize = 4;
var eps = 20.0;


var colourScale = d3.scale.category20();


initPoints();
updateInput();
initCanvas();
dbscan();

console.log(clusters);
markCluster();


function updateInput() {
   if (! vis) return; // Not ready yet

   var dist = +d3.select('#distSlider').node().value;
   var size = +d3.select('#sizeSlider').node().value;

   d3.select('#distLabel').text(dist);
   d3.select('#sizeLabel').text(size);

   console.log('dist = ' +  dist, ' size = ' + size);
   eps = dist;
   minimumSize = size;
   resetData();
   dbscan();
   markCluster();
}

function resetData() {
   clusters = [];

   d3.selectAll('.point').style('fill', '#DDD')
   dataPoints.forEach(function(p) {
      p.isVisited = false;
      p.isClustered = false;
      delete p['clusterIndex'];
   });
}


function markCluster() {
   clusters.forEach(function(cluster, clusterIndex) {
      cluster.forEach(function(p) {
         p.clusterIndex = clusterIndex;
      });
   });


   var inCluster = vis.selectAll('.point').filter(function(d) {
      return d.hasOwnProperty('clusterIndex');
   });

   inCluster.transition().duration(100)
     .style('fill', function(d) {
      return colourScale(d.clusterIndex);
     })
     .style('opacity', 0.8);

   // Draw them summary bars

   d3.select('#summary').selectAll('*').remove();

   var summary = d3.select('#summary').attr('height', 400)
     .append('g').attr('transform', 'translate(0, 10)');

   summary.append('rect')
     .attr('x', 2)
     .attr('y', 0)
     .attr('height', clusters.length * 9 + 10)
     .attr('width', 2)
     .style('fill', '#aaa');

   var bars = summary.selectAll('.bar')
     .data(clusters)
     .enter()
     .append('rect')
     .classed('bar', true)
     .attr('x', 5)
     .attr('y', function(d, i) { return 3 + i*9; })
     .attr('width', 1)
     .attr('height', 8)
     .style('fill', function(d, i) {
        return colourScale(i);
     });
   bars.transition().duration(100).attr('width', function(d) { return d.length; });




}


function dbscan() {
   dataPoints.forEach(function(p, i) {
      if (p.isVisited === true) return;

      p.isVisited = true;

      var neighbours = _neighbours(p);

      if (neighbours.length >= minimumSize) {
         var newCluster = [];
         expandCluster(p, neighbours, newCluster);
         clusters.push(newCluster);
      }

   });
}

function expandCluster(point, neighbours, c) {
   c.push(point);
   for (var i=0; i < neighbours.length; i++) {
      var p = neighbours[i];
      if (p.isVisited === false) {
         p.isVisited = true;
         var neighboursPrime = _neighbours(p);
         if (neighboursPrime.length >= minimumSize) {
            neighbours = neighbours.concat(neighboursPrime);
         }
      }
      if (p.isClustered === false) {
         p.isClustered = true;
         c.push(p);
      }
   }
}


function _dist(p1, p2) {
   return Math.sqrt( (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));
}


function _neighbours(point) {
   var result = [];
   dataPoints.forEach(function(p) {
      if (_dist(p, point) < eps) {
         result.push(p);
      }
   })
   return result;
}


function initPoints() {
   var padding = 10;

   for (var i=0; i < numPoints; i++) {
      dataPoints.push({
         id: i,
         x: padding + Math.random()* (w - 2*padding),
         y: padding + Math.random()* (h - 2*padding),
         isVisited: false,
         isClustered: false
      });
   }
}


function initCanvas() {
   vis = d3.select('#canvas').attr('width', w).attr('height', h).append('g');
   vis.append('rect').attr('width', w).attr('height', h).style('fill', '#EEE');

   vis.selectAll('.point')
     .data(dataPoints)
     .enter()
     .append('circle')
     .classed('point', true)
     .attr({
        cx: function(d) { return d.x; },
        cy: function(d) { return d.y; },
        r: 5
     })
     .style({
        opacity: 0.7,
        fill: '#DDD',
        stroke: '#AAA'
     });

}

</script>
</html>
